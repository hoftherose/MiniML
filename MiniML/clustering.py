# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/Clustering.ipynb (unless otherwise specified).

__all__ = ['Categorize', 'cat', 'plot_iris', 'k', 'it', 'data', 'centers', 'dist', 'get_distances', 'calc_centers',
           'np_results', 'results', 'c_flowers', 'one_hot', 'one_hot_show', 'c_flowers', 'c_flowers', 'c_plot_iris',
           'c_calc_centers', 'update_u', 'distances', 'c_data', 'U', 'it', 'eps']

# Cell
import torch
import pandas
import random
from fastcore.all import *

# Cell
from bokeh.plotting import figure, show
from bokeh.io import output_notebook
from bokeh.sampledata.iris import flowers

# Cell
class Categorize(Transform):
    as_item_force=False
    def __init__(self, data: pandas.core.series.Series):
        data = L(list(data)).unique()
        self.idx2val = data
        self.val2idx = data.val2idx()

    def encodes(self, idx: int): return self.idx2val[idx]
    def decodes(self, cat: str): return self.val2idx[cat]

# Cell
cat = Categorize(flowers["species"])
flowers["species_idx"] = flowers.species.map(cat.decodes)

# Cell
def plot_iris(data: pandas.core.frame.DataFrame):
    colormap = {0: 'red', 1: 'green', 2: 'blue'}
    colors = [colormap[x] for x in data['species_idx']]

    p = figure(title = "Iris Morphology")
    p.xaxis.axis_label = 'Petal Length'
    p.yaxis.axis_label = 'Petal Width'

    p.circle(data["petal_length"], data["petal_width"], color=colors, fill_alpha=0.2, size=10)

    output_notebook()

    show(p)
    return p

# Cell
k = 3
it = 100
data = torch.tensor(flowers[flowers.columns[:4]].values)
centers = data[random.sample(range(len(data)), k)]

# Cell
def dist(point:torch.tensor, cluster:torch.tensor):
    return sum((point[0]-cluster[1])**2)

# Cell
def get_distances(data:torch.tensor, centers:torch.tensor):
    data_ = data.unsqueeze(1)
    diff = torch.cat([data_,data_,data_], dim=1)-centers
    return torch.sum(diff**2, 2)

# Cell
def calc_centers(data:torch.tensor, groups:torch.tensor, k:int):
    centers = [torch.mean(data[groups==i], dim=0) for i in range(k)]
    return torch.cat([c.unsqueeze(0) for c in centers], dim=0)

# Cell
for x in range(it):
    distances = get_distances(data, centers)
    groups = torch.argmin(distances, 1)
    centers = calc_centers(data, groups, 3)

# Cell
np_results = np.concatenate((data.numpy(), groups.unsqueeze(1).numpy()), 1)
results = pandas.DataFrame(np_results, columns=flowers.columns[flowers.columns!="species"])

# Cell
c_flowers = flowers
one_hot = pandas.get_dummies(c_flowers['species'], dtype=float)
one_hot_show = pandas.get_dummies(c_flowers['species'].replace({'setosa': 'red_fill', 'versicolor': 'green_fill', 'virginica': 'blue_fill'}), dtype=float)
c_flowers = c_flowers.join(one_hot)
c_flowers = c_flowers.join(one_hot_show)
c_flowers

# Cell
from bokeh.models import CheckboxGroup, HoverTool, ColumnDataSource, CustomJS, Slider
from bokeh.layouts import column, layout

# Cell
def c_plot_iris(data: pandas.core.frame.DataFrame):
    source = ColumnDataSource(data)
    TOOLTIPS = tooltips

    p = figure(title = 'Iris Morphology', tooltips=TOOLTIPS)
    p.xaxis.axis_label = 'Petal Length'
    p.yaxis.axis_label = 'Petal Width'

    red_circles = p.circle("petal_length", "petal_width", color="red", fill_alpha="red_fill", size=10, line_alpha=0, source=source)
    green_circles = p.circle("petal_length", "petal_width", color="green", fill_alpha="green_fill", size=10, line_alpha=0, source=source)
    blue_circles = p.circle("petal_length", "petal_width", color="blue", fill_alpha="blue_fill", size=10, line_alpha=0, source=source)

    select = CheckboxGroup(labels=["red","green","blue"], active=[0,1,2], width=100)
    slider = Slider(start=0.1, end=1, value=1, step=.01, title="Transparency")

    param_update = CustomJS(args=dict(source=source, slider=slider, select=select), code=update_js)
    hide_update = CustomJS(code=hide_js, args=dict(red=red_circles, green=green_circles, blue=blue_circles, select=select))
    slider.js_on_change('value', param_update)
    select.js_on_change('active', hide_update)
    tweak = column(select, slider)
    output_notebook()
    show(layout([[p, tweak]]))

# Cell
def c_calc_centers(U:torch.Tensor, points:torch.Tensor):
    weighted_sum = points.t()@U
    weighted_mean = weighted_sum/U.sum(dim=0)
    return weighted_mean.t()

# Cell
def update_u(centers:torch.Tensor, point:torch.Tensor):
    d_ij = distances(centers, point)
    dist_proportions = d_ij/d_ij.t().unsqueeze(2)
    return 1/dist_proportions.sum(dim=0)

# Cell
def distances(centers:torch.Tensor, point:torch.Tensor):
    diff = point.unsqueeze(1)-centers
    return (diff**2).sum(dim=2)

# Cell
c_data = torch.FloatTensor(c_flowers[c_flowers.columns[:4]].values)
U = torch.zeros(150,3).scatter(1,torch.randint(3,(150,1)), 1.)

it = 100
eps = 10e-8

# Cell
for x in range(it):
    centers = c_calc_centers(U, c_data)
    U_new = update_u(centers, c_data)
    if ((U-U_new)**2).sum() < eps: break
    U = U_new
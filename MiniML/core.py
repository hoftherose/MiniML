# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/Clustering.ipynb (unless otherwise specified).

__all__ = ['Categorize', 'cat', 'plot_iris', 'k', 'it', 'data', 'centers', 'dist', 'get_distances', 'calc_centers',
           'np_results', 'results', 'c_flowers', 'one_hot', 'c_flowers', 'c_plot_iris', 'c_calc_centers', 'c_data', 'U']

# Cell
import torch
import pandas
import random
from fastcore.all import *

# Cell
from bokeh.plotting import figure, show
from bokeh.io import output_notebook
from bokeh.sampledata.iris import flowers

# Cell
class Categorize(Transform):
    as_item_force=False
    def __init__(self, data: pandas.core.series.Series):
        data = L(list(data)).unique()
        self.idx2val = data
        self.val2idx = data.val2idx()

    def encodes(self, idx: int): return self.idx2val[idx]
    def decodes(self, cat: str): return self.val2idx[cat]

# Cell
cat = Categorize(flowers["species"])
flowers["species_idx"] = flowers.species.map(cat.decodes)

# Cell
def plot_iris(data: pandas.core.frame.DataFrame):
    colormap = {0: 'red', 1: 'green', 2: 'blue'}
    colors = [colormap[x] for x in data['species_idx']]

    p = figure(title = "Iris Morphology")
    p.xaxis.axis_label = 'Petal Length'
    p.yaxis.axis_label = 'Petal Width'

    p.circle(data["petal_length"], data["petal_width"], color=colors, fill_alpha=0.2, size=10)

    output_notebook()

    show(p)
    return p

# Cell
k = 3
it = 100
data = torch.tensor(flowers[flowers.columns[:4]].values)
centers = data[random.sample(range(len(data)), k)]

# Cell
def dist(point:torch.tensor, cluster:torch.tensor):
    return sum((point[0]-cluster[1])**2)

# Cell
def get_distances(data:torch.tensor, centers:torch.tensor):
    data_ = data.unsqueeze(1)
    diff = torch.cat([data_,data_,data_], dim=1)-centers
    return torch.sum(diff**2, 2)

# Cell
def calc_centers(data:torch.tensor, groups:torch.tensor, k:int):
    centers = [torch.mean(data[groups==i], dim=0) for i in range(k)]
    return torch.cat([c.unsqueeze(0) for c in centers], dim=0)

# Cell
for x in range(it):
    distances = get_distances(data, centers)
    groups = torch.argmin(distances, 1)
    centers = calc_centers(data, groups, 3)

# Cell
np_results = np.concatenate((data.numpy(), groups.unsqueeze(1).numpy()), 1)
results = pandas.DataFrame(np_results, columns=flowers.columns[flowers.columns!="species"])

# Cell
c_flowers = flowers
one_hot = pandas.get_dummies(c_flowers['species'], dtype=float)
c_flowers = c_flowers.join(one_hot)

# Cell
from bokeh.models import CheckboxGroup, HoverTool, ColumnDataSource, CustomJS, Slider
from bokeh.layouts import column

# Cell
def c_plot_iris(data: pandas.core.frame.DataFrame):
    source = ColumnDataSource(data)

    TOOLTIPS = """
        <div>
            <h3>petal_length:</h3> @petal_length
            <h3>petal_width:</h3> @petal_width
            <h3>Setosa:</h3> @setosa
            <h3>Versicolor:</h3> @versicolor
            <h3>Virginica:</h3> @virginica
        </div>
    """

    p = figure(title = 'Iris Morphology', tooltips=TOOLTIPS)
    p.xaxis.axis_label = 'Petal Length'
    p.yaxis.axis_label = 'Petal Width'

    p.circle("petal_length", "petal_width", color="red", fill_alpha="setosa", size=10, line_alpha=0, source=source)
    p.circle("petal_length", "petal_width", color="green", fill_alpha="versicolor", size=10, line_alpha=0, source=source)
    p.circle("petal_length", "petal_width", color="blue", fill_alpha="virginica", size=10, line_alpha=0, source=source)

    select = CheckboxGroup(labels=["0","1","2"], active=[0,1,2])
    slider = Slider(start=0.1, end=1, value=1, step=.01, title="Transparency")

    slider_update = CustomJS(args=dict(source=source, slider=slider), code=slider_js)
    slider.js_on_change('value', slider_update)

    #select_update = CustomJS(args=dict(source=source, select), code=select_js)
    #select.js_on_change('value', select_update)

    output_notebook()
    show(column(select, slider, p))

# Cell
def c_calc_centers(U:torch.Tensor, points:torch.Tensor):
    weighted_sum = points.t()@U
    weighted_mean = weighted_sum/U.sum(dim=0)
    return weighted_mean.t()

# Cell
c_data = torch.FloatTensor(c_flowers[c_flowers.columns[:4]].values)
U = torch.zeros(150,3).scatter_(1, torch.randint(3, (150,1)), 1.)